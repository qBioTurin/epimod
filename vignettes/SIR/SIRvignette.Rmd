---
title: "EpiMod: an example of analisys"
author: "Beccuti Marco, Castagno Paolo, Pernice Simone"
output: 
  pdf_document:
    toc: true
    toc_depth: 3
    fig_caption: yes
bibliography: biblio.bib  
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r wrap-hook,include = FALSE }
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```

## SIR model



$$ \begin{aligned} \frac{dx}{dt} &= \alpha x-\beta xy,\\
{\frac {dy}{dt}}&=\delta xy-\gamma y, \end{aligned}$$

where:

1. $x$ is the number of prey (for example, rabbits);
2. $y$ is the number of some predator (for example, foxes);
3. ${\tfrac {dy}{dt}}$ and ${\tfrac {dx}{dt}}$ represent the instantaneous growth rates of the two populations;
4. $t$ represents time;
5. $\alpha,\ \beta,\ \gamma,\ \theta$ are positive real parameters describing the interaction of the two species.


## Guideline for epimod package
### How to start 

Before starting the analysis we have to download the Docker containers.


```{r,echo=FALSE}
library(epimod)

downloadContainers()
``` 

### Something to know
All the files used in this guide are stored in the folder *Example* inside the *epimod* package.
All the functions generate the following files:

- *Docker ID is:*, meaning that ...;
- *Docker exit status: 0*, meaning that ... .

###  Model generation

```{r, linewidth = 80}

model_generation(net_fname = "SIR.PNPRO")

``` 


###  Sensitivity analysis

The R function *sensitivity_analysis()* implements the sensitivity analysis taking as input 

1. the \emph{.solver} file generated by the *model_generation*}}* function,
the total number of samplings to be performed,
2. the final solution time,
3. the time step defining the frequency at which explicit estimates for the system values are desired,
4. parameters_fname (*Functions_list.csv*): a textual file in which the  parameters to be studied are listed associated with their range of variability.
significato delle colonne, e che serve il ; come sep, spazi non nei path
An example is given by the following file, where
```{r, echo= FALSE}
read.csv("Functions_list.csv", header=FALSE,sep=";")
```

5. functions_fname (*Functions.R*): ...
```{r, linewidth = 80 }
init_generation<-function(min_init , max_init)
{
    # min/max are vectors = first position interval values for the first place
    # and second position for the second place.

   i_1=runif(n=1,min=min_init[1],max=max_init[1])
   i_2=runif(n=1,min=min_init[2],max=max_init[2])

   return( c(i_1,i_2) )
}
```
6. target_value_fname (*Target.R*): ... .

Assuming the following fixed rates:


#### PRCC and ranking
This step is necessary if we are interested to calculate the PRCC  to identify among the input  parameters  which are the sensitive ones (i.e., those that have a great effect on the model behaviour). 
This  may simplify the calibration step reducing (1) the number of variables to be estimated and (2) the search  space associated with each estimated parameter.

In order to run the simulations, the user must provide

1. the reference dataset;
2. the definition of a function to compute the distance (or error) between the models' output and the reference dataset itself.

In this case the reference dataset is the trajectory obtained from the starting point 1 predator and 1 prey. Similarly to the previouos step, we generate different initial conditions for the system but in this case. 


The function defining the distance takes in inputs only the reference data and the simulation's output (i.e. a trajectory); an example it could be the following:

```{r, linewidth = 80 }
msqd<-function(reference, output)
{
    Infect <- output[,"I"]

    diff.Infect <- sum(( Infect - reference )^2 )

    return(diff.Infect)
}
```

where the squared error between the Predator and Prey trajectories obtaained from the simulation and the corresponding reference trajectories are calculated, respectively named *diff.Predator* and *diff.Prey*. Then, the sum of these errors is returned. Our purpose will be to minimize (see next section) this function in order to identify the trajectory most similar to the reference data, therefore 

```{r, linewidth = 80 }
Target<-function(output)
{
    ret <- output[,"I"]
    return(as.data.frame(ret))
}
```

Let us note that the name of the distance and target function must have the same name of the corresponding R file.

```{r, linewidth = 80}

## Simple version where only the transition rates vary.
sensitivity<-sensitivity_analysis(n_config = 200,
                                  parameters_fname = "Functions_list.csv",                                          solver_fname = "SIR.solver",
                                  reference_data = "reference_data.csv",
                                  distance_measure_fname = "msqd.R" ,
                                  target_value_fname = "Target.R" ,
                                  parallel_processors = 1,
                                  f_time = 7*10, # weeks
                                  s_time = 1 # days      
                                  )
```

```{r, eval=FALSE }

## Version where only the PRCC is calculated
sensitivity<-sensitivity_analysis(n_config = 100,
                                  parameters_fname = "Functions_list.csv",                                          solver_fname = "SIR.solver",
                                  target_value_fname = "Target.R" ,
                                  parallel_processors = 1,
                                  f_time = 7*10, # weeks
                                  s_time = 1 # days
                                  )

## Version where only the ranking is calculated
sensitivity<-sensitivity_analysis(n_config = 100,
                                  parameters_fname = "Functions_list.csv",                                          solver_fname = "SIR.solver",
                                  reference_data = "reference_data.csv",
                                  distance_measure_fname = "msqd.R" ,
                                  parallel_processors = 1,
                                  f_time = 7*10, # weeks
                                  s_time = 1 # days
                                  )

## Complete and more complex version where all the parameters for calculating the PRCC and the ranking are considered, and the initial conditions vary too.

sensitivity<-sensitivity_analysis(n_config = 100,
                                  parameters_fname = "Functions_list2.csv",                                         functions_fname = "Functions.R",
                                  solver_fname = "SIR.solver",
                                  reference_data = "reference_data.csv",
                                  distance_measure_fname = "msqd.R" ,
                                  target_value_fname = "Target.R" ,
                                  parallel_processors = 2,
                                  f_time = 7*10, # weeks
                                  s_time = 1 # days
                                  )
```


```{r, linewidth=80, echo=F, message=F }

##############################
## Let draw the orbits characterizing the phase-space
##############################

library(ggplot2)

load("./results_Sensitivity/SIR-sensitivity.RData")
load("./results_Sensitivity/ranking_SIR-sensitivity.RData")
reference <- as.data.frame(t(read.csv("reference_data.csv",
                                      header = FALSE,
                                      sep = "")))

# Then, we read all the trajectories generated saving them in a list called
# ListTraces. List that will be rewritten as a data frame in order to use ggplot.
# ConfigID represents the initial condition associated to each trajectory,
# which was generated by using the function implemented in the file Functions.R .

listFile<-list.files("./results_Sensitivity/",
                     pattern = ".trace")

configID<-t(sapply(1:length(listFile),
                   function(x){
                       return(c(x,config[[1]][[x]][[3]]))
                   }) )

id.traces<-as.numeric(gsub("[^[:digit:].]", "",listFile) )

ListTraces<-lapply(id.traces,
                   function(x){
                       trace.tmp=read.csv(paste0(
                           "./results_Sensitivity/SIR-sensitivity-",
                           x,
                           ".trace"), sep = "")
                       trace.tmp=data.frame(trace.tmp,ID=rank[which(rank[,2]==x),1])
                       return(trace.tmp)
                   })

traces <- do.call("rbind", ListTraces)

ggplot( )+
    geom_line(data=traces,
              aes(x=Time/7,y=I,group=ID,col=ID))+
    geom_line(data=reference,
              aes(x=V1/7,y=V3),
              col="red")+
    theme(axis.text=element_text(size=18),
        axis.title=element_text(size=20,face="bold"),
        legend.text=element_text(size=18),
        legend.title=element_text(size=20,face="bold"),
        legend.position="right",
        legend.key.size = unit(1.3, "cm"),
        legend.key.width = unit(1.3,"cm") )+
    labs(x="Weeks", y="Number of Infects",col="Distance")

ggplot( )+
    geom_line(data=traces,
              aes(x=Time,y=S,group=ID,col=ID))+
    geom_line(data=reference,
              aes(x=V1/7,y=V2),
              col="red")+
    theme(axis.text=element_text(size=18),
        axis.title=element_text(size=20,face="bold"),
        legend.text=element_text(size=18),
        legend.title=element_text(size=20,face="bold"),
        legend.position="right",
        legend.key.size = unit(1.3, "cm"),
        legend.key.width = unit(1.3,"cm") )+
    labs(x="Weeks", y="Number of Infects",col="Distance")

ggplot( )+
    geom_line(data=traces,
              aes(x=Time,y=R,group=ID,col=ID))+
    geom_line(data=reference,
              aes(x=V1/7,y=V4),
              col="red")+
    theme(axis.text=element_text(size=18),
        axis.title=element_text(size=20,face="bold"),
        legend.text=element_text(size=18),
        legend.title=element_text(size=20,face="bold"),
        legend.position="right",
        legend.key.size = unit(1.3, "cm"),
        legend.key.width = unit(1.3,"cm") )+
    labs(x="Weeks", y="Number of Infects",col="Distance")
```

![PRCC for the **Predator** place over time.](./results_Sensitivity/prcc_SIR-sensitivity.pdf)

Running the sensisitivity analysis, we can replicate the results reported on Wikipedia, *https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations*. Indeed, textual file for each generated parameter combination (i.e. 20) containing the system  solution is returned. Each file is characterized by as many rows as the solution time points (obtained dividing the final time point by the time step) and as many columns as the system components.
We can now generate the phase-space plot, where it is possible to see that the predators thrive when there are plentiful prey but, ultimately, outstrip their food supply and decline. As the predator population is low, the prey population will increase again. These dynamics continue in a cycle of growth and decline.

Let us note that it is possible to run the sensitivity analysys without PRCC or ranking, in the case that we are intersted only on to have a general idea of the simulation' results.

### Calibration analysis

```{r, linewidth = 80 }



model_calibration(out_fname = "calibration",
                  parameters_fname = "Functions_list.csv",                                          solver_fname = "SIR.solver",
                  reference_data = "reference_data.csv",
                  distance_measure_fname = "msqd.R" ,
                  f_time = 7*10, # weeks
                  s_time = 1, # days      
                  # Vectors to control the optimization
                  ini_v = c(0.142857,0.0001428),
                  ub_v = c(0.3, 0.0005),
                  lb_v = c(0, 0),
                  optim_vector_mod = F,
                  max.call = 30
)

```



### Whatif Analysis
